[{"content":"委托构造函数调用同一类的另一个构造函数，通过添加执行初始化步骤的函数来减少重复代码。\nstruct A { int a; float b; bool c; // standard constructor: A(int a1, float b1, bool c1) : a(a1), b(b1), c(c1) { // do a lot of work } A(int a1, float b1) : A(a1, b1, false) {} // delegate construtor A(float b1) : A(100, b1, false) {} // delegate construtor }; ","permalink":"http://localhost:1313/program-language/cpp/delegating-constructor/","summary":"\u003cp\u003e委托构造函数调用同一类的另一个构造函数，通过添加执行初始化步骤的函数来减少重复代码。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003estruct A {\nint a;\nfloat b;\nbool c;\n// standard constructor:\nA(int a1, float b1, bool c1) : a(a1), b(b1), c(c1) {\n// do a lot of work\n}\nA(int a1, float b1) : A(a1, b1, false) {} // delegate construtor\nA(float b1) : A(100, b1, false) {} // delegate construtor\n};\n\u003c/code\u003e\u003c/pre\u003e","title":"Delegating Constructor"},{"content":"find_package() ","permalink":"http://localhost:1313/program-language/cmake/find-packge/","summary":"\u003cpre tabindex=\"0\"\u003e\u003ccode\u003efind_package()\n\u003c/code\u003e\u003c/pre\u003e","title":"Find Packge"},{"content":"基础数据 Types Category Meaning float 浮点数 有小数部分的数字 ","permalink":"http://localhost:1313/program-language/cpp/fundamental-datatype/","summary":"\u003ch1 id=\"基础数据\"\u003e基础数据\u003c/h1\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eTypes\u003c/th\u003e\n          \u003cth\u003eCategory\u003c/th\u003e\n          \u003cth\u003eMeaning\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003efloat\u003c/td\u003e\n          \u003ctd\u003e浮点数\u003c/td\u003e\n          \u003ctd\u003e有小数部分的数字\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"Fundamental Datatype"},{"content":"常见错误 语法错误 语义错误 调试通用方法 找到问题的根本原因 了解问题发生的原因 确定如何解决问题 修复导致问题的问题 测试确保问题已被解决 重新测试确保没有出现新的问题 ","permalink":"http://localhost:1313/program-language/cpp/debug/","summary":"\u003ch1 id=\"常见错误\"\u003e常见错误\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e语法错误\u003c/li\u003e\n\u003cli\u003e语义错误\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"调试通用方法\"\u003e调试通用方法\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e找到问题的根本原因\u003c/li\u003e\n\u003cli\u003e了解问题发生的原因\u003c/li\u003e\n\u003cli\u003e确定如何解决问题\u003c/li\u003e\n\u003cli\u003e修复导致问题的问题\u003c/li\u003e\n\u003cli\u003e测试确保问题已被解决\u003c/li\u003e\n\u003cli\u003e重新测试确保没有出现新的问题\u003c/li\u003e\n\u003c/ol\u003e","title":"Debug"},{"content":"设计步骤 明确目标 明确需要什么，而不是怎么做 明确工具、目标和备份计划 将复杂问题拆分为简单问题 弄明白事件顺序 实施步骤 概述主要功能 实施每个函数 测试 建议 保持程序能够简单的开始运行 随时间增加功能 一次专注于一个任务 边写边测试代码 不要投资在早期的完美代码 优化可维护性，而不是性能 ","permalink":"http://localhost:1313/program-language/cpp/design-your-program/","summary":"\u003ch1 id=\"设计步骤\"\u003e设计步骤\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e明确目标\u003c/li\u003e\n\u003cli\u003e明确需要什么，而不是怎么做\u003c/li\u003e\n\u003cli\u003e明确工具、目标和备份计划\u003c/li\u003e\n\u003cli\u003e将复杂问题拆分为简单问题\u003c/li\u003e\n\u003cli\u003e弄明白事件顺序\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"实施步骤\"\u003e实施步骤\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e概述主要功能\u003c/li\u003e\n\u003cli\u003e实施每个函数\u003c/li\u003e\n\u003cli\u003e测试\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"建议\"\u003e建议\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e保持程序能够简单的开始运行\u003c/li\u003e\n\u003cli\u003e随时间增加功能\u003c/li\u003e\n\u003cli\u003e一次专注于一个任务\u003c/li\u003e\n\u003cli\u003e边写边测试代码\u003c/li\u003e\n\u003cli\u003e不要投资在早期的完美代码\u003c/li\u003e\n\u003cli\u003e优化可维护性，而不是性能\u003c/li\u003e\n\u003c/ol\u003e","title":"Design Your Program"},{"content":"","permalink":"http://localhost:1313/time-serises-forecast/temperal-fusion-transformer/","summary":"","title":"Temperal Fusion Transformer"},{"content":"categorical是一种数据类型，用在有限、固定数量的可能值上\n","permalink":"http://localhost:1313/program-language/python/pandas/categorical/","summary":"\u003cp\u003e\u003ccode\u003ecategorical\u003c/code\u003e是一种数据类型，用在有限、固定数量的可能值上\u003c/p\u003e","title":"Categorical"},{"content":"Pytest ","permalink":"http://localhost:1313/program-language/python/python%E6%B5%8B%E8%AF%95-pytest/","summary":"\u003ch1 id=\"pytest\"\u003ePytest\u003c/h1\u003e","title":"Python测试 Pytest"},{"content":"状态代码 main()的返回值\n状态代码用于指示程序是否成功，状态码0表示程序运行正常，非零状态代码通常用于表示某种故障。\n如果未提供return语句，函数main()隐式返回0\n函数 返回值函数: 函数只能返回单个值 非返回值函数: void作为返回类型 void函数不需要return语句\nDo not repeat yourself\n函数参数 未引用的参数: 函数参数在函数体中没有被使用 未命名的参数: 省略函数参数名称，如void DoSome(int /*count*/) 局部变量 局部变量的定义应该尽可能接近第一次合理使用\nforward declaration 可以解决循环依赖的问题\n","permalink":"http://localhost:1313/program-language/cpp/functions/","summary":"\u003ch1 id=\"状态代码\"\u003e状态代码\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003emain()\u003c/code\u003e的返回值\u003c/p\u003e\n\u003cp\u003e状态代码用于指示程序是否成功，状态码\u003ccode\u003e0\u003c/code\u003e表示程序运行正常，非零状态代码通常用于表示某种故障。\u003c/p\u003e\n\u003cp\u003e如果未提供\u003ccode\u003ereturn\u003c/code\u003e语句，函数\u003ccode\u003emain()\u003c/code\u003e隐式返回0\u003c/p\u003e\n\u003ch1 id=\"函数\"\u003e函数\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e返回值函数: \u003cstrong\u003e函数只能返回单个值\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e非返回值函数: \u003ccode\u003evoid\u003c/code\u003e作为返回类型\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003evoid\u003c/code\u003e函数不需要\u003ccode\u003ereturn\u003c/code\u003e语句\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDo not repeat yourself\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"函数参数\"\u003e函数参数\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e未引用的参数: 函数参数在函数体中没有被使用\u003c/li\u003e\n\u003cli\u003e未命名的参数: 省略函数参数名称，如\u003ccode\u003evoid DoSome(int /*count*/)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"局部变量\"\u003e局部变量\u003c/h1\u003e\n\u003cp\u003e局部变量的定义应该尽可能接近第一次合理使用\u003c/p\u003e\n\u003ch1 id=\"forward-declaration\"\u003eforward declaration\u003c/h1\u003e\n\u003cp\u003e可以解决循环依赖的问题\u003c/p\u003e","title":"Functions"},{"content":"对象 Object是一个能够存储值的存储区域（通常是内存）\n变量初始化 变量初始化 复制初始化 int a = 5; 允许向下转换\n直接初始化 int a(5); 允许向下转换\n列表初始化 int a{5}; 允许对列表的值进行初始化\n不允许向下转换\n值初始化和零初始化 int width {}; int width {0}; [[maybe_unused]] 允许编译器接受未使用的变量，不生成警告\n[[maybe_unused]] double pi {3.14}; Reference learncpp ","permalink":"http://localhost:1313/program-language/cpp/object-and-variable/","summary":"\u003ch1 id=\"对象\"\u003e对象\u003c/h1\u003e\n\u003cp\u003eObject是一个能够存储值的存储区域（通常是内存）\u003c/p\u003e\n\u003ch1 id=\"变量初始化\"\u003e变量初始化\u003c/h1\u003e\n\u003ch2 id=\"变量初始化-1\"\u003e变量初始化\u003c/h2\u003e\n\u003ch3 id=\"复制初始化\"\u003e复制初始化\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e    int a = 5;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e允许向下转换\u003c/p\u003e\n\u003ch3 id=\"直接初始化\"\u003e直接初始化\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e    int a(5);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e允许向下转换\u003c/p\u003e\n\u003ch3 id=\"列表初始化\"\u003e列表初始化\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e    int a{5};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e允许对列表的值进行初始化\u003c/p\u003e\n\u003cp\u003e不允许向下转换\u003c/p\u003e\n\u003ch2 id=\"值初始化和零初始化\"\u003e值初始化和零初始化\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e    int width {};\n    int width {0};\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"maybe_unused\"\u003e[[maybe_unused]]\u003c/h2\u003e\n\u003cp\u003e允许编译器接受未使用的变量，不生成警告\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e    [[maybe_unused]] double pi {3.14};\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"reference\"\u003eReference\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://www.learncpp.com/\"\u003elearncpp\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e","title":"对象和变量"},{"content":"python 类的super()函数用于将方法调用委托给type的父类或兄弟类\n","permalink":"http://localhost:1313/program-language/python/%E9%9A%8F%E7%AC%94/","summary":"\u003ch1 id=\"python\"\u003epython\u003c/h1\u003e\n\u003cp\u003e类的super()函数用于将方法调用委托给type的父类或兄弟类\u003c/p\u003e","title":"随笔"},{"content":"Polymorphism c++的多态性是指一个实体可以根据上下文来变换自身行为的能力。\n多态处理可以发生在以下两种情况：\nCompile-time(静态): 在程序开始时被调用实例已经清楚 Run-time(动态): 被调用实例仅在执行时才清楚，例如依赖于run-time值 c++中的多态主要与动态多态(overriding)相联系\n多态性形式 Ad-hoc polymorphism: 涉及到一组独立指定的类型，如函数重载 Parametric polymorphism: 涉及到泛型，如模板 subtyping: 在一个元素的子类型上操作时，如虚函数 Reference CMAKE COMPILE_OPTION 取代了 COMPILE_FLAGS CMAKE__COMPILER指定编译器\n","permalink":"http://localhost:1313/program-language/cpp/cpp-polymorphism/","summary":"\u003ch1 id=\"polymorphism\"\u003ePolymorphism\u003c/h1\u003e\n\u003cp\u003ec++的多态性是指一个实体可以根据上下文来变换自身行为的能力。\u003c/p\u003e\n\u003cp\u003e多态处理可以发生在以下两种情况：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eCompile-time(静态): 在程序开始时被调用实例已经清楚\u003c/li\u003e\n\u003cli\u003eRun-time(动态): 被调用实例仅在执行时才清楚，例如依赖于run-time值\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003ec++中的多态主要与动态多态(overriding)相联系\u003c/p\u003e\n\u003ch1 id=\"多态性形式\"\u003e多态性形式\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003eAd-hoc polymorphism: 涉及到一组独立指定的类型，如函数重载\u003c/li\u003e\n\u003cli\u003eParametric polymorphism: 涉及到泛型，如模板\u003c/li\u003e\n\u003cli\u003esubtyping: 在一个元素的子类型上操作时，如虚函数\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"reference\"\u003eReference\u003c/h1\u003e\n\u003ch1 id=\"cmake\"\u003eCMAKE\u003c/h1\u003e\n\u003cp\u003eCOMPILE_OPTION 取代了 COMPILE_FLAGS\nCMAKE_\u003cLANGUAGE\u003e_COMPILER指定编译器\u003c/p\u003e","title":"C++ Polymorphism"}]